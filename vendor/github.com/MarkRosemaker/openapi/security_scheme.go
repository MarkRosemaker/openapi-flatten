package openapi

import (
	"fmt"
	"net/url"
	"strings"

	"github.com/MarkRosemaker/errpath"
)

// SecurityScheme defines a security scheme that can be used by the operations.
//
// Supported schemes are HTTP authentication, an API key (either as a header, a cookie parameter or as a query parameter), mutual TLS (use of a client certificate), OAuth2's common flows (implicit, password, client credentials and authorization code) as defined in [RFC6749], and [OpenID Connect Discovery].
// Please note that as of 2020, the implicit flow is about to be deprecated by [OAuth 2.0 Security Best Current Practice]. Recommended for most use case is Authorization Code Grant flow with PKCE.
// ([Specification])
//
// [RFC6749]: https://tools.ietf.org/html/rfc6749
// [OpenID Connect Discovery]: https://tools.ietf.org/html/draft-ietf-oauth-discovery-06
// [OAuth 2.0 Security Best Current Practice]: https://tools.ietf.org/html/draft-ietf-oauth-security-topics
// [Specification]: https://spec.openapis.org/oas/v3.1.0#security-scheme-object
type SecurityScheme struct {
	// The type of the security scheme. Valid values are `"apiKey"`, `"http"`, `"mutualTLS"`, `"oauth2"`, `"openIdConnect"`.
	Type SecuritySchemeType `json:"type" yaml:"type"`
	// A description for security scheme. CommonMark syntax MAY be used for rich text representation.
	Description string `json:"description,omitempty" yaml:"description,omitempty"`
	// The name of the header, query or cookie parameter to be used for the API key.
	Name string `json:"name,omitempty" yaml:"name,omitempty"`
	// The location of the API key. Valid values are `"query"`, `"header"` or `"cookie"`.
	In SecuritySchemeIn `json:"in,omitempty" yaml:"in,omitempty"`
	// The name of the HTTP Authorization scheme to be used in the Authorization header as defined in RFC7235, e.g. "bearer". The values used SHOULD be registered in the IANA Authentication Scheme registry.
	Scheme string `json:"scheme,omitempty" yaml:"scheme,omitempty"`
	// A hint to the client to identify how the bearer token is formatted, e.g. "jwt". Bearer tokens are usually generated by an authorization server, so this information is primarily for documentation purposes.
	BearerFormat string `json:"bearerFormat,omitempty" yaml:"bearerFormat,omitempty"`
	// An object containing configuration information for the flow types supported by the OAuth2 security scheme.
	Flows *OAuthFlows `json:"flows,omitempty" yaml:"flows,omitempty"`
	// OpenId Connect URL to discover OAuth2 configuration values. This MUST be in the form of a URL. The OpenID Connect standard requires the use of TLS.
	OpenIdConnectURL *url.URL `json:"openIdConnectUrl,omitempty" yaml:"openIdConnectUrl,omitempty"`

	// This object MAY be extended with Specification Extensions.
	Extensions Extensions `json:",inline" yaml:"-"`
}

const (
	// SecuritySchemeBearer is the value of SecurityScheme.Scheme for bearer tokens.
	SecuritySchemeBearer = "bearer"
	// SecuritySchemeBasic is the value of SecurityScheme.Scheme for basic authentication.
	SecuritySchemeBasic = "basic"
)

// Validate the values of SecurityScheme.
func (s *SecurityScheme) Validate() error {
	if s.Type == "" {
		return &errpath.ErrField{Field: "type", Err: &errpath.ErrRequired{}}
	}

	if err := s.Type.Validate(); err != nil {
		return &errpath.ErrField{Field: "type", Err: err}
	}

	s.Description = strings.TrimSpace(s.Description)

	switch s.Type {
	case SecuritySchemeTypeAPIKey:
		if s.Name == "" {
			return &errpath.ErrField{Field: "name", Err: &errpath.ErrRequired{}}
		}

		if s.In == "" {
			return &errpath.ErrField{Field: "in", Err: &errpath.ErrRequired{}}
		}

		if err := s.In.Validate(); err != nil {
			return &errpath.ErrField{Field: "in", Err: err}
		}
	case SecuritySchemeTypeHTTP:
		if s.Scheme == "" {
			return &errpath.ErrField{Field: "scheme", Err: &errpath.ErrRequired{}}
		}

		if SecuritySchemeBearer == strings.ToLower(s.Scheme) {
			s.Scheme = SecuritySchemeBearer // unify

			if s.BearerFormat == "" {
				return &errpath.ErrField{Field: "bearerFormat", Err: &errpath.ErrRequired{}}
			}
		}
	case SecuritySchemeTypeMutualTLS: // nothing to do
	case SecuritySchemeTypeOAuth2:
		if s.Flows == nil {
			return &errpath.ErrField{Field: "flows", Err: &errpath.ErrRequired{}}
		}

		if err := s.Flows.Validate(); err != nil {
			return &errpath.ErrField{Field: "flows", Err: err}
		}
	case SecuritySchemeTypeOpenIDConnect:
		if s.OpenIdConnectURL == nil {
			return &errpath.ErrField{Field: "openIdConnectUrl", Err: &errpath.ErrRequired{}}
		}
	default:
		return fmt.Errorf("unimplemented type %q", s.Type)
	}

	return validateExtensions(s.Extensions)
}

func (l *loader) collectSecuritySchemeRef(r *SecuritySchemeRef, ref ref) {
	if r.Value != nil {
		l.collectSecurityScheme(r.Value, ref)
	}
}

func (l *loader) collectSecurityScheme(s *SecurityScheme, ref ref) {
	l.securitySchemes[ref.String()] = s
}

func (l *loader) resolveSecuritySchemeRef(r *SecuritySchemeRef) error {
	return resolveRef(r, l.securitySchemes, nil)
}
